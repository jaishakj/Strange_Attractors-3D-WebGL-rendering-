<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Strange Attractor Visualiser</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=DM+Sans:wght@300;400;500&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0f;
    --panel: #0f0f18;
    --panel-border: #1e1e2e;
    --accent: #e05252;
    --accent2: #5284e0;
    --text: #c8c8d8;
    --text-muted: #5a5a72;
    --slider-track: #1e1e2e;
    --toggle-off: #2a2a3a;
    --toggle-on: #e05252;
    --input-bg: #14141f;
  }

  html, body {
    width: 100%; height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    overflow: hidden;
  }

  #app {
    display: flex;
    width: 100%;
    height: 100vh;
  }

  /* ── SIDEBAR ── */
  #sidebar {
    width: 300px;
    min-width: 300px;
    background: var(--panel);
    border-right: 1px solid var(--panel-border);
    display: flex;
    flex-direction: column;
    padding: 20px;
    gap: 18px;
    overflow-y: auto;
    transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
    position: relative;
    z-index: 10;
  }

  #sidebar.collapsed {
    transform: translateX(-270px);
  }

  #collapse-btn {
    position: absolute;
    right: -14px;
    top: 20px;
    width: 28px;
    height: 28px;
    background: var(--panel);
    border: 1px solid var(--panel-border);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 10px;
    transition: all 0.2s;
    z-index: 20;
  }
  #collapse-btn:hover { color: var(--text); border-color: var(--accent); }

  /* ── TOGGLE ── */
  .toggle-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .toggle {
    position: relative;
    width: 40px;
    height: 22px;
    flex-shrink: 0;
  }
  .toggle input { opacity: 0; width: 0; height: 0; }
  .toggle-slider {
    position: absolute;
    inset: 0;
    background: var(--toggle-off);
    border-radius: 11px;
    cursor: pointer;
    transition: 0.25s;
  }
  .toggle-slider::before {
    content: '';
    position: absolute;
    width: 16px; height: 16px;
    left: 3px; top: 3px;
    background: var(--text-muted);
    border-radius: 50%;
    transition: 0.25s;
  }
  .toggle input:checked + .toggle-slider { background: var(--toggle-on); }
  .toggle input:checked + .toggle-slider::before {
    transform: translateX(18px);
    background: #fff;
  }

  .toggle-label {
    font-size: 12px;
    font-weight: 500;
    color: var(--text-muted);
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }

  /* ── SELECT ── */
  .field-label {
    font-size: 10px;
    font-weight: 500;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.8px;
    margin-bottom: 6px;
  }

  .custom-select {
    position: relative;
  }

  .custom-select select {
    width: 100%;
    padding: 9px 32px 9px 12px;
    background: var(--input-bg);
    border: 1px solid var(--panel-border);
    border-radius: 6px;
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    appearance: none;
    cursor: pointer;
    transition: border-color 0.2s;
    outline: none;
  }
  .custom-select select:hover,
  .custom-select select:focus { border-color: var(--accent); }

  .custom-select::after {
    content: '▾';
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--text-muted);
    pointer-events: none;
    font-size: 11px;
  }

  /* ── SLIDERS ── */
  .param-group {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .param-item {}

  .param-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    margin-bottom: 6px;
  }

  .param-name {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--text-muted);
    text-transform: lowercase;
  }

  .param-value {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--accent);
    font-weight: 700;
  }

  .slider-wrap {
    position: relative;
  }

  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 3px;
    background: var(--slider-track);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px; height: 14px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 6px rgba(224,82,82,0.5);
    transition: box-shadow 0.2s;
  }
  input[type="range"]:hover::-webkit-slider-thumb {
    box-shadow: 0 0 10px rgba(224,82,82,0.8);
  }

  /* ── BUTTONS ── */
  .btn-row {
    display: flex;
    gap: 10px;
  }

  .btn {
    flex: 1;
    padding: 9px 0;
    border-radius: 6px;
    font-family: 'DM Sans', sans-serif;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    border: 1px solid var(--panel-border);
    background: var(--input-bg);
    color: var(--text);
    letter-spacing: 0.3px;
  }
  .btn:hover { border-color: var(--accent); color: var(--accent); }
  .btn.primary {
    background: transparent;
    border-color: var(--accent);
    color: var(--accent);
  }
  .btn.primary:hover { background: rgba(224,82,82,0.1); }

  /* ── CHECKBOX ── */
  .check-row {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
  }

  .check-row input[type="checkbox"] {
    -webkit-appearance: none;
    width: 14px; height: 14px;
    border: 1px solid var(--panel-border);
    border-radius: 3px;
    background: var(--input-bg);
    cursor: pointer;
    position: relative;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .check-row input[type="checkbox"]:checked {
    background: var(--accent);
    border-color: var(--accent);
  }
  .check-row input[type="checkbox"]:checked::after {
    content: '✓';
    position: absolute;
    color: white;
    font-size: 10px;
    top: -1px;
    left: 1px;
  }
  .check-label {
    font-size: 12px;
    color: var(--text-muted);
    user-select: none;
  }

  /* ── DIVIDER ── */
  .divider {
    height: 1px;
    background: var(--panel-border);
  }

  /* ── CANVAS AREA ── */
  #canvas-wrap {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  canvas { display: block; }

  /* ── HEADER ── */
  #header {
    position: absolute;
    top: 28px;
    left: 36px;
    pointer-events: none;
    z-index: 5;
  }

  #header h1 {
    font-family: 'Space Mono', monospace;
    font-size: 26px;
    font-weight: 700;
    color: #e8e8f0;
    letter-spacing: -0.5px;
    line-height: 1.1;
  }

  #header p {
    font-size: 12px;
    color: var(--text-muted);
    margin-top: 6px;
    letter-spacing: 0.3px;
  }

  /* ── TOP-RIGHT CONTROLS ── */
  #top-right {
    position: absolute;
    top: 20px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    z-index: 5;
  }

  .icon-btn {
    width: 32px; height: 32px;
    background: rgba(15,15,24,0.8);
    border: 1px solid var(--panel-border);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-muted);
    font-size: 11px;
    transition: all 0.2s;
    backdrop-filter: blur(8px);
  }
  .icon-btn:hover { border-color: var(--accent); color: var(--accent); }

  /* ── LEARN MODE PANEL ── */
  #learn-panel {
    position: absolute;
    bottom: 24px;
    right: 24px;
    width: 300px;
    background: rgba(15,15,24,0.92);
    border: 1px solid var(--panel-border);
    border-radius: 10px;
    padding: 18px;
    backdrop-filter: blur(12px);
    display: none;
    z-index: 5;
  }
  #learn-panel.active { display: block; }
  #learn-panel h3 {
    font-family: 'Space Mono', monospace;
    font-size: 13px;
    color: var(--accent);
    margin-bottom: 10px;
  }
  #learn-panel p {
    font-size: 12px;
    line-height: 1.7;
    color: var(--text-muted);
  }
  #learn-panel .eq {
    font-family: 'Space Mono', monospace;
    font-size: 11px;
    color: var(--accent2);
    background: var(--input-bg);
    padding: 10px 12px;
    border-radius: 6px;
    margin-top: 10px;
    line-height: 1.8;
  }

  /* ── STATS ── */
  #stats {
    position: absolute;
    bottom: 24px;
    left: 24px;
    font-family: 'Space Mono', monospace;
    font-size: 10px;
    color: var(--text-muted);
    line-height: 1.8;
    z-index: 5;
    pointer-events: none;
  }

  /* Scrollbar */
  #sidebar::-webkit-scrollbar { width: 4px; }
  #sidebar::-webkit-scrollbar-track { background: transparent; }
  #sidebar::-webkit-scrollbar-thumb { background: var(--panel-border); border-radius: 2px; }
</style>
</head>
<body>
<div id="app">
  <!-- SIDEBAR -->
  <div id="sidebar">
    <button id="collapse-btn" title="Collapse">◀</button>

    <div class="toggle-row">
      <label class="toggle">
        <input type="checkbox" id="learn-toggle"/>
        <span class="toggle-slider"></span>
      </label>
      <span class="toggle-label">Learn mode</span>
    </div>

    <div>
      <div class="field-label">Select attractor</div>
      <div class="custom-select">
        <select id="attractor-select">
          <option value="lorenz">Lorenz</option>
          <option value="rossler">Rössler</option>
          <option value="dadras">Dadras</option>
          <option value="aizawa">Aizawa</option>
          <option value="halvorsen">Halvorsen</option>
          <option value="chen">Chen</option>
        </select>
      </div>
    </div>

    <div class="divider"></div>
    <div class="param-group" id="params"></div>
    <div class="divider"></div>

    <div class="btn-row">
      <button class="btn" id="reset-btn">Reset</button>
      <button class="btn primary" id="save-btn">Save values</button>
    </div>

    <div class="divider"></div>

    <label class="check-row">
      <input type="checkbox" id="density-toggle"/>
      <span class="check-label">Use density colouring (slower performance)</span>
    </label>

    <div>
      <div class="field-label">Density colorscale</div>
      <div class="custom-select">
        <select id="colorscale-select">
          <option value="blue_white">Blue → White</option>
          <option value="heat">Heat</option>
          <option value="plasma">Plasma</option>
          <option value="viridis">Viridis</option>
          <option value="neon">Neon</option>
        </select>
      </div>
    </div>

    <label class="check-row">
      <input type="checkbox" id="animate-toggle"/>
      <span class="check-label">Animate trajectory</span>
    </label>

    <label class="check-row">
      <input type="checkbox" id="rotate-toggle" checked/>
      <span class="check-label">Auto-rotate</span>
    </label>
  </div>

  <!-- CANVAS AREA -->
  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>

    <div id="header">
      <h1>Strange Attractor Visualiser</h1>
      <p>Interactive 3D exploration of classic chaotic systems.</p>
    </div>

    <div id="top-right">
      <div class="icon-btn" id="screenshot-btn" title="Screenshot">⬛</div>
    </div>

    <div id="learn-panel">
      <h3 id="learn-title">Lorenz Attractor</h3>
      <p id="learn-desc"></p>
      <div class="eq" id="learn-eq"></div>
    </div>

    <div id="stats">
      <div>POINTS: <span id="stat-points">0</span></div>
      <div>ATTRACTOR: <span id="stat-name">Lorenz</span></div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ─────────────────────────────────────────────
//  ATTRACTOR DEFINITIONS
// ─────────────────────────────────────────────
const ATTRACTORS = {
  lorenz: {
    name: 'Lorenz',
    params: {
      sigma: { default: 10,  min: 1,  max: 30,  step: 0.1 },
      rho:   { default: 28,  min: 1,  max: 60,  step: 0.1 },
      beta:  { default: 2.667, min: 0.1, max: 8, step: 0.01 },
    },
    dt: 0.005,
    steps: 80000,
    scale: 0.15,
    init: () => [0.1, 0, 0],
    step(p, v) {
      const [x,y,z] = p;
      const {sigma,rho,beta} = v;
      return [sigma*(y-x), x*(rho-z)-y, x*y-beta*z];
    },
    learn: {
      desc: 'Discovered by Edward Lorenz in 1963 while modelling atmospheric convection. The butterfly-shaped attractor became the icon of chaos theory — sensitivity to initial conditions means tiny differences grow exponentially.',
      eq: 'dx/dt = σ(y − x)\ndy/dt = x(ρ − z) − y\ndz/dt = xy − βz'
    }
  },
  rossler: {
    name: 'Rössler',
    params: {
      a: { default: 0.2, min: 0, max: 1, step: 0.01 },
      b: { default: 0.2, min: 0, max: 1, step: 0.01 },
      c: { default: 5.7, min: 1, max: 14, step: 0.1 },
    },
    dt: 0.01,
    steps: 60000,
    scale: 0.05,
    init: () => [0.1, 0, 0],
    step(p, v) {
      const [x,y,z] = p;
      const {a,b,c} = v;
      return [-y-z, x+a*y, b+z*(x-c)];
    },
    learn: {
      desc: 'Proposed by Otto Rössler in 1976 as the simplest possible strange attractor. It has a single spiral lobe and is used to study period-doubling routes to chaos.',
      eq: 'dx/dt = −y − z\ndy/dt = x + ay\ndz/dt = b + z(x − c)'
    }
  },
  dadras: {
    name: 'Dadras',
    params: {
      a: { default: 3,  min: -10, max: 10, step: 0.1 },
      b: { default: 2.7,min: -10, max: 10, step: 0.1 },
      c: { default: 1.7,min: -10, max: 10, step: 0.1 },
      d: { default: 2,  min: -10, max: 10, step: 0.1 },
      e: { default: 9,  min: -10, max: 10, step: 0.1 },
    },
    dt: 0.003,
    steps: 80000,
    scale: 0.06,
    init: () => [0.1, -0.4, 0.5],
    step(p, v) {
      const [x,y,z] = p;
      const {a,b,c,d,e} = v;
      return [y-a*x+b*y*z, c*y-x*z+z, d*x*y-e*z];
    },
    learn: {
      desc: 'A 3D chaotic system with five parameters, producing a striking double-winged form. Named after researcher Sara Dadras, it exhibits rich bifurcation behaviour as parameters vary.',
      eq: 'dx/dt = y − ax + byz\ndy/dt = cy − xz + z\ndz/dt = dxy − ez'
    }
  },
  aizawa: {
    name: 'Aizawa',
    params: {
      a: { default: 0.95, min: 0.1, max: 2, step: 0.01 },
      b: { default: 0.7,  min: 0.1, max: 2, step: 0.01 },
      c: { default: 0.6,  min: 0.1, max: 2, step: 0.01 },
      d: { default: 3.5,  min: 0.1, max: 8, step: 0.1  },
      e: { default: 0.25, min: 0,   max: 1, step: 0.01 },
      f: { default: 0.1,  min: 0,   max: 1, step: 0.01 },
    },
    dt: 0.01,
    steps: 60000,
    scale: 0.6,
    init: () => [0.1, 0, 0],
    step(p, v) {
      const [x,y,z] = p;
      const {a,b,c,d,e,f} = v;
      return [(z-b)*x-d*y, d*x+(z-b)*y, c+a*z-z*z*z/3-(x*x+y*y)*(1+e*z)+f*z*x*x*x];
    },
    learn: {
      desc: 'The Aizawa attractor creates a toroidal (donut-shaped) structure — a rare geometry among strange attractors. Its six parameters allow fine control over the torus shape and chaos intensity.',
      eq: 'dx/dt = (z−b)x − dy\ndy/dt = dx + (z−b)y\ndz/dt = c + az − z³/3 − (x²+y²)(1+ez) + fzx³'
    }
  },
  halvorsen: {
    name: 'Halvorsen',
    params: {
      a: { default: 1.4, min: 0.5, max: 3, step: 0.01 },
    },
    dt: 0.005,
    steps: 70000,
    scale: 0.1,
    init: () => [-5, 0, 0],
    step(p, v) {
      const [x,y,z] = p;
      const {a} = v;
      return [-a*x-4*y-4*z-y*y, -a*y-4*z-4*x-z*z, -a*z-4*x-4*y-x*x];
    },
    learn: {
      desc: 'A symmetric attractor with three-fold rotational symmetry. The Halvorsen system produces a distinctive trefoil-like form where all three equations are cyclic permutations of each other.',
      eq: 'dx/dt = −ax − 4y − 4z − y²\ndy/dt = −ay − 4z − 4x − z²\ndz/dt = −az − 4x − 4y − x²'
    }
  },
  chen: {
    name: 'Chen',
    params: {
      a: { default: 35, min: 5,  max: 60, step: 0.5 },
      b: { default: 3,  min: 0.5,max: 10, step: 0.1 },
      c: { default: 28, min: 5,  max: 50, step: 0.5 },
    },
    dt: 0.002,
    steps: 60000,
    scale: 0.04,
    init: () => [0.1, 0, 0],
    step(p, v) {
      const [x,y,z] = p;
      const {a,b,c} = v;
      return [a*(y-x), (c-a)*x-x*z+c*y, x*y-b*z];
    },
    learn: {
      desc: 'Discovered by Guanrong Chen in 1999, this is a sibling system to Lorenz but not topologically equivalent. It exhibits a double-scroll butterfly that appears similar but has fundamentally different dynamics.',
      eq: 'dx/dt = a(y − x)\ndy/dt = (c−a)x − xz + cy\ndz/dt = xy − bz'
    }
  }
};

// ─────────────────────────────────────────────
//  COLORSCALES
// ─────────────────────────────────────────────
function getColor(t, scheme) {
  t = Math.max(0, Math.min(1, t));
  switch(scheme) {
    case 'heat':
      if(t < 0.33) return lerpColor([20,0,50],[200,0,100],t/0.33);
      if(t < 0.66) return lerpColor([200,0,100],[255,180,0],(t-0.33)/0.33);
      return lerpColor([255,180,0],[255,255,255],(t-0.66)/0.34);
    case 'plasma':
      if(t < 0.25) return lerpColor([13,8,135],[126,3,168],t/0.25);
      if(t < 0.5)  return lerpColor([126,3,168],[204,71,120],(t-0.25)/0.25);
      if(t < 0.75) return lerpColor([204,71,120],[248,149,64],(t-0.5)/0.25);
      return lerpColor([248,149,64],[240,249,33],(t-0.75)/0.25);
    case 'viridis':
      if(t < 0.25) return lerpColor([68,1,84],[59,82,139],t/0.25);
      if(t < 0.5)  return lerpColor([59,82,139],[33,145,140],(t-0.25)/0.25);
      if(t < 0.75) return lerpColor([33,145,140],[94,201,98],(t-0.5)/0.25);
      return lerpColor([94,201,98],[253,231,37],(t-0.75)/0.25);
    case 'neon':
      if(t < 0.5) return lerpColor([0,255,200],[200,0,255],t/0.5);
      return lerpColor([200,0,255],[255,200,0],(t-0.5)/0.5);
    default: // blue_white
      if(t < 0.5) return lerpColor([20,40,100],[60,130,220],t/0.5);
      return lerpColor([60,130,220],[200,230,255],(t-0.5)/0.5);
  }
}

function lerpColor(a, b, t) {
  return [
    a[0]+(b[0]-a[0])*t,
    a[1]+(b[1]-a[1])*t,
    a[2]+(b[2]-a[2])*t
  ];
}

// ─────────────────────────────────────────────
//  COMPUTE TRAJECTORY
// ─────────────────────────────────────────────
function computeTrajectory(attractorKey, params) {
  const def = ATTRACTORS[attractorKey];
  let p = def.init();
  const positions = [];
  const N = def.steps;
  const dt = def.dt;
  const scale = def.scale;

  for(let i = 0; i < N; i++) {
    const d = def.step(p, params);
    p = [
      p[0] + d[0] * dt,
      p[1] + d[1] * dt,
      p[2] + d[2] * dt
    ];
    if(i > 1000) { // skip transient
      positions.push(p[0]*scale, p[2]*scale, p[1]*scale);
    }
  }
  return new Float32Array(positions);
}

// ─────────────────────────────────────────────
//  DENSITY COLORING
// ─────────────────────────────────────────────
function computeDensityColors(positions, colorscheme) {
  const N = positions.length / 3;
  const colors = new Float32Array(N * 3);
  const density = new Float32Array(N);
  const K = 50;

  for(let i = 0; i < N; i++) {
    let d = 0;
    for(let j = Math.max(0,i-K); j < Math.min(N,i+K); j++) {
      const dx = positions[i*3]   - positions[j*3];
      const dy = positions[i*3+1] - positions[j*3+1];
      const dz = positions[i*3+2] - positions[j*3+2];
      d += 1 / (1 + dx*dx + dy*dy + dz*dz);
    }
    density[i] = d;
  }

  let minD = Infinity, maxD = -Infinity;
  for(let i = 0; i < N; i++) {
    minD = Math.min(minD, density[i]);
    maxD = Math.max(maxD, density[i]);
  }

  for(let i = 0; i < N; i++) {
    const t = (density[i] - minD) / (maxD - minD);
    const c = getColor(t, colorscheme);
    colors[i*3]   = c[0] / 255;
    colors[i*3+1] = c[1] / 255;
    colors[i*3+2] = c[2] / 255;
  }
  return colors;
}

function computeVelocityColors(positions, colorscheme) {
  const N = positions.length / 3;
  const colors = new Float32Array(N * 3);

  for(let i = 0; i < N; i++) {
    const j = Math.min(i+1, N-1);
    const dx = positions[j*3]   - positions[i*3];
    const dy = positions[j*3+1] - positions[i*3+1];
    const dz = positions[j*3+2] - positions[i*3+2];
    const speed = Math.sqrt(dx*dx+dy*dy+dz*dz);
    const c = getColor(Math.min(speed*200,1), colorscheme);
    colors[i*3]   = c[0]/255;
    colors[i*3+1] = c[1]/255;
    colors[i*3+2] = c[2]/255;
  }
  return colors;
}

// ─────────────────────────────────────────────
//  THREE.JS SETUP
// ─────────────────────────────────────────────
const canvas = document.getElementById('canvas');
const wrap = document.getElementById('canvas-wrap');

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x0a0a0f, 1);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, 1, 0.01, 1000);
camera.position.set(0, 0, 12);

// Orbit controls (manual)
let isDragging = false, lastMouse = {x:0,y:0};
let spherical = { theta: 0, phi: Math.PI/2, r: 12 };

canvas.addEventListener('mousedown', e => { isDragging = true; lastMouse = {x:e.clientX,y:e.clientY}; });
canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mousemove', e => {
  if(!isDragging) return;
  const dx = e.clientX - lastMouse.x;
  const dy = e.clientY - lastMouse.y;
  spherical.theta -= dx * 0.005;
  spherical.phi = Math.max(0.1, Math.min(Math.PI-0.1, spherical.phi + dy*0.005));
  lastMouse = {x:e.clientX,y:e.clientY};
  autoRotate = false;
});
canvas.addEventListener('wheel', e => {
  spherical.r = Math.max(3, Math.min(50, spherical.r + e.deltaY * 0.02));
}, {passive:true});

// Touch
let lastTouch = null;
canvas.addEventListener('touchstart', e => { lastTouch = e.touches[0]; });
canvas.addEventListener('touchmove', e => {
  if(!lastTouch) return;
  const t = e.touches[0];
  const dx = t.clientX - lastTouch.clientX;
  const dy = t.clientY - lastTouch.clientY;
  spherical.theta -= dx * 0.005;
  spherical.phi = Math.max(0.1, Math.min(Math.PI-0.1, spherical.phi + dy*0.005));
  lastTouch = t;
  autoRotate = false;
}, {passive:true});

function updateCamera() {
  camera.position.x = spherical.r * Math.sin(spherical.phi) * Math.sin(spherical.theta);
  camera.position.y = spherical.r * Math.cos(spherical.phi);
  camera.position.z = spherical.r * Math.sin(spherical.phi) * Math.cos(spherical.theta);
  camera.lookAt(0,0,0);
}

// ─────────────────────────────────────────────
//  POINT CLOUD
// ─────────────────────────────────────────────
let pointsMesh = null;
let animIndex = 0;
let isAnimating = false;
let autoRotate = true;

function buildPointCloud(positions, colors) {
  if(pointsMesh) {
    scene.remove(pointsMesh);
    pointsMesh.geometry.dispose();
    pointsMesh.material.dispose();
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.015,
    vertexColors: true,
    transparent: true,
    opacity: 0.85,
    sizeAttenuation: true,
  });

  pointsMesh = new THREE.Points(geo, mat);
  scene.add(pointsMesh);
  animIndex = 0;
  document.getElementById('stat-points').textContent = (positions.length/3).toLocaleString();
}

// ─────────────────────────────────────────────
//  STATE & PARAMS
// ─────────────────────────────────────────────
let currentAttractor = 'lorenz';
let currentParams = {};
let savedParams = {};
let useDensity = false;
let colorscheme = 'blue_white';
let allPositions = null;

function getDefaultParams(key) {
  const def = ATTRACTORS[key];
  const p = {};
  for(const [k,v] of Object.entries(def.params)) p[k] = v.default;
  return p;
}

function rebuildViz() {
  const def = ATTRACTORS[currentAttractor];
  allPositions = computeTrajectory(currentAttractor, currentParams);

  let colors;
  if(useDensity) {
    colors = computeDensityColors(allPositions, colorscheme);
  } else {
    colors = computeVelocityColors(allPositions, colorscheme);
  }

  buildPointCloud(allPositions, colors);
  document.getElementById('stat-name').textContent = def.name;
  isAnimating = document.getElementById('animate-toggle').checked;
}

// ─────────────────────────────────────────────
//  PARAM UI
// ─────────────────────────────────────────────
function buildParamUI() {
  const def = ATTRACTORS[currentAttractor];
  currentParams = Object.assign({}, savedParams[currentAttractor] || getDefaultParams(currentAttractor));

  const container = document.getElementById('params');
  container.innerHTML = '';

  for(const [key, cfg] of Object.entries(def.params)) {
    const item = document.createElement('div');
    item.className = 'param-item';
    item.innerHTML = `
      <div class="param-header">
        <span class="param-name">${key}</span>
        <span class="param-value" id="val-${key}">${currentParams[key].toFixed(2)}</span>
      </div>
      <input type="range"
        id="slider-${key}"
        min="${cfg.min}" max="${cfg.max}" step="${cfg.step}"
        value="${currentParams[key]}"/>
    `;
    container.appendChild(item);

    item.querySelector(`#slider-${key}`).addEventListener('input', e => {
      const v = parseFloat(e.target.value);
      currentParams[key] = v;
      document.getElementById(`val-${key}`).textContent = v.toFixed(2);
      rebuildViz();
    });
  }
}

// ─────────────────────────────────────────────
//  LEARN MODE
// ─────────────────────────────────────────────
function updateLearnPanel() {
  const def = ATTRACTORS[currentAttractor];
  document.getElementById('learn-title').textContent = def.name + ' Attractor';
  document.getElementById('learn-desc').textContent = def.learn.desc;
  document.getElementById('learn-eq').textContent = def.learn.eq;
}

// ─────────────────────────────────────────────
//  EVENT WIRING
// ─────────────────────────────────────────────
document.getElementById('attractor-select').addEventListener('change', e => {
  currentAttractor = e.target.value;
  buildParamUI();
  updateLearnPanel();
  rebuildViz();
});

document.getElementById('learn-toggle').addEventListener('change', e => {
  document.getElementById('learn-panel').classList.toggle('active', e.target.checked);
});

document.getElementById('density-toggle').addEventListener('change', e => {
  useDensity = e.target.checked;
  rebuildViz();
});

document.getElementById('colorscale-select').addEventListener('change', e => {
  colorscheme = e.target.value;
  rebuildViz();
});

document.getElementById('animate-toggle').addEventListener('change', e => {
  isAnimating = e.target.checked;
  if(isAnimating) animIndex = 0;
});

document.getElementById('rotate-toggle').addEventListener('change', e => {
  autoRotate = e.target.checked;
});

document.getElementById('reset-btn').addEventListener('click', () => {
  delete savedParams[currentAttractor];
  buildParamUI();
  rebuildViz();
});

document.getElementById('save-btn').addEventListener('click', () => {
  savedParams[currentAttractor] = Object.assign({}, currentParams);
  const btn = document.getElementById('save-btn');
  const orig = btn.textContent;
  btn.textContent = 'Saved ✓';
  setTimeout(() => btn.textContent = orig, 1500);
});

// Collapse
const sidebar = document.getElementById('sidebar');
const colBtn = document.getElementById('collapse-btn');
let collapsed = false;
colBtn.addEventListener('click', () => {
  collapsed = !collapsed;
  sidebar.classList.toggle('collapsed', collapsed);
  colBtn.textContent = collapsed ? '▶' : '◀';
  onResize();
});

// Screenshot
document.getElementById('screenshot-btn').addEventListener('click', () => {
  renderer.render(scene, camera);
  const url = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = `attractor-${currentAttractor}.png`;
  a.click();
});

// ─────────────────────────────────────────────
//  RESIZE
// ─────────────────────────────────────────────
function onResize() {
  const w = wrap.clientWidth;
  const h = wrap.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);

// ─────────────────────────────────────────────
//  ANIMATION LOOP
// ─────────────────────────────────────────────
let frameCount = 0;
function animate() {
  requestAnimationFrame(animate);
  frameCount++;

  if(autoRotate) {
    spherical.theta += 0.003;
  }
  updateCamera();

  // Trajectory animation
  if(isAnimating && pointsMesh && allPositions) {
    const step = 500;
    animIndex = Math.min(animIndex + step, allPositions.length/3);
    const visible = allPositions.slice(0, animIndex*3);
    const colors = computeVelocityColors(visible, colorscheme);
    pointsMesh.geometry.setAttribute('position', new THREE.BufferAttribute(visible, 3));
    pointsMesh.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    pointsMesh.geometry.setDrawRange(0, animIndex);
    if(animIndex >= allPositions.length/3) { isAnimating = false; }
  }

  renderer.render(scene, camera);
}

// ─────────────────────────────────────────────
//  INIT
// ─────────────────────────────────────────────
currentAttractor = 'lorenz';
buildParamUI();
updateLearnPanel();
onResize();
rebuildViz();
animate();
</script>
</body>
</html>
